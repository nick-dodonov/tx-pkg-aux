load("@tx-kit-ext//rules/build:tx_binary.bzl", "tx_binary")

tx_binary(
    name = "http-wasm-fetch",
    srcs = glob(["*.cpp"]),
    deps = [
        "@tx-pkg-aux//src/pkg-boot",
    ],
    linkopts = [
        "-sFETCH=1",
        "-sASYNCIFY",
        "-sEXPORTED_RUNTIME_METHODS=lengthBytesUTF8,stringToUTF8,UTF8ToString",
        # "--post-js", "$(location :try_wasm_fetch_post_js)",
        # "-sEXIT_RUNTIME=1",
        # "-sENVIRONMENT=web,node",
    ],
    data = [
        ":try_wasm_fetch_post_js",
    ],
    target_compatible_with = select({
        "@platforms//cpu:wasm32": [],
        "//conditions:default": ["@platforms//:incompatible"],
    }),
)

# Post-JS file to polyfill fetch/XMLHttpRequest for Node.js and detect runtime
genrule(
    name = "try_wasm_fetch_post_js",
    outs = ["try_wasm_fetch_post.js"],
    cmd = """cat > $@ << 'EOF'
// Detect runtime environment and set global flag
if (typeof Module !== 'undefined') {
  Module.__EMSCRIPTEN_IS_BROWSER__ = typeof window !== 'undefined' && typeof navigator !== 'undefined';
}

// Polyfill for XMLHttpRequest in Node.js using native fetch
if (typeof XMLHttpRequest === 'undefined' && typeof global !== 'undefined') {
  global.XMLHttpRequest = function() {
    this.responseText = '';
    this.response = null;
    this.status = 0;
    this.statusText = '';
    this.readyState = 0;
    this.onreadystatechange = null;
    this.onload = null;
    this.onerror = null;
    this.ontimeout = null;
    this.timeout = 0;
  };
  
  global.XMLHttpRequest.prototype.open = function(method, url, async) {
    this.method = method;
    this.url = url;
    this.async = async !== false;
  };
  
  global.XMLHttpRequest.prototype.send = function(data) {
    const self = this;
    const url = this.url;
    const method = this.method || 'GET';
    
    // Use native Node.js fetch (available in Node 18+) or require node-fetch
    let fetchFunc;
    if (typeof fetch !== 'undefined') {
      fetchFunc = fetch;
    } else {
      try {
        const fetch = require('node-fetch');
        fetchFunc = fetch;
      } catch (e) {
        console.error('node-fetch not available');
        return;
      }
    }
    
    const fetchOptions = {
      method: method,
      headers: {}
    };
    
    fetchFunc(url, fetchOptions)
      .then(res => {
        self.status = res.status;
        self.statusText = res.statusText;
        self.readyState = 4;
        return res.arrayBuffer();
      })
      .then(buffer => {
        // Store as ArrayBuffer, Emscripten will extract numBytes from it
        self.response = buffer;
        self.responseText = new TextDecoder().decode(buffer);
        if (self.onload) {
          self.onload();
        }
        if (self.onreadystatechange && runtimeKeepaliveCounter > 0) {
          self.onreadystatechange();
        }
      })
      .catch(err => {
        self.status = 0;
        self.readyState = 4;
        if (self.onerror) {
          self.onerror(err);
        }
        if (self.onreadystatechange && runtimeKeepaliveCounter > 0) {
            self.onreadystatechange();
        }
      });
  };
}
EOF
""",
)
